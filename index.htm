<!doctype html>
<html lang="pl">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>DS Europe – Hero</title>
  <style>
    :root{
      --bg1:#ffffff;
      --bg2:#f5f7fb;
    }
    body{ margin:0; font-family: system-ui, -apple-system, Segoe UI, Roboto, Arial, sans-serif; background: var(--bg1); }
    .hero{
      position: relative;
      height: min(72vh, 640px);
      min-height: 520px;
      overflow: hidden;
      background: radial-gradient(ellipse at center, var(--bg1) 0%, var(--bg2) 55%, var(--bg1) 100%);
    }
    canvas{ position:absolute; inset:0; width:100%; height:100%; display:block; }
    .overlay{
      position:absolute; inset:0;
      display:flex; align-items:center; justify-content:center;
      pointer-events:none;
    }
    .logo{
      width:min(420px, 76vw);
      height:auto;
      filter: drop-shadow(0 14px 34px rgba(0,0,0,.12));
      transform: translateZ(0);
    }

    /* Delikatny “glass” pod logo (premium, ale subtelnie) */
    .glass{
      position:absolute;
      width:min(680px, 88vw);
      height:min(220px, 28vh);
      border-radius: 28px;
      background: rgba(255,255,255,.55);
      backdrop-filter: blur(10px);
      -webkit-backdrop-filter: blur(10px);
      box-shadow: 0 22px 70px rgba(0,0,0,.08);
      border: 1px solid rgba(255,255,255,.65);
      opacity: .55;
    }

    @media (prefers-reduced-motion: reduce){
      .glass{ display:none; }
    }
  </style>
</head>
<body>
  <section class="hero" id="hero">
    <canvas id="c"></canvas>
    <div class="overlay">
      <div class="glass"></div>
      <img class="logo" src="logo.png" alt="ds europe" />
    </div>
  </section>

  <script type="module">
    import * as THREE from "https://unpkg.com/three@0.160.0/build/three.module.js";
    import { EffectComposer } from "https://unpkg.com/three@0.160.0/examples/jsm/postprocessing/EffectComposer.js";
    import { RenderPass } from "https://unpkg.com/three@0.160.0/examples/jsm/postprocessing/RenderPass.js";
    import { UnrealBloomPass } from "https://unpkg.com/three@0.160.0/examples/jsm/postprocessing/UnrealBloomPass.js";

    const canvas = document.getElementById("c");
    const hero = document.getElementById("hero");

    // Renderer
    const renderer = new THREE.WebGLRenderer({
      canvas,
      antialias: true,
      alpha: true,
      powerPreference: "high-performance"
    });
    renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
    renderer.setSize(hero.clientWidth, hero.clientHeight, false);

    // Scene + Camera
    const scene = new THREE.Scene();
    const camera = new THREE.PerspectiveCamera(42, hero.clientWidth/hero.clientHeight, 0.1, 200);
    camera.position.set(0, 0, 26);

    // Postprocessing (subtelny bloom = “premium”)
    const composer = new EffectComposer(renderer);
    composer.addPass(new RenderPass(scene, camera));
    const bloom = new UnrealBloomPass(
      new THREE.Vector2(hero.clientWidth, hero.clientHeight),
      0.65,   // strength
      0.85,   // radius
      0.22    // threshold
    );
    composer.addPass(bloom);

    // --- Premium mesh: punkty + “wires” w 3D, animacja w shaderze (GPU noise) ---

    // Ustawienia jakości
    const POINTS = 140;               // 120–180
    const CONNECTIONS_PER_POINT = 3;  // 2–4
    const RADIUS = 18;

    // Rozkład: „pusty środek” pod logo, większa gęstość po bokach
    function samplePoint(){
      // rozkład eliptyczny + odrzucanie środka
      for(let tries=0; tries<40; tries++){
        const x = (Math.random()*2 - 1) * RADIUS;
        const y = (Math.random()*2 - 1) * (RADIUS*0.55);
        const z = (Math.random()*2 - 1) * 4.2;

        // maska środka
        const cx = x/9.0, cy = y/4.0;
        const center = Math.exp(-(cx*cx + cy*cy));  // 0..1
        if (Math.random() < (1 - 0.78*center)) return new THREE.Vector3(x,y,z);
      }
      return new THREE.Vector3(
        (Math.random()*2 - 1)*RADIUS,
        (Math.random()*2 - 1)*(RADIUS*0.55),
        (Math.random()*2 - 1)*4.2
      );
    }

    const base = new Float32Array(POINTS * 3);
    const phase = new Float32Array(POINTS);
    for(let i=0;i<POINTS;i++){
      const p = samplePoint();
      base[i*3+0]=p.x; base[i*3+1]=p.y; base[i*3+2]=p.z;
      phase[i]=Math.random()*Math.PI*2;
    }

    // Punkty (Points) z własnym shaderem
    const pointsGeo = new THREE.BufferGeometry();
    pointsGeo.setAttribute("position", new THREE.BufferAttribute(base, 3));
    pointsGeo.setAttribute("aPhase", new THREE.BufferAttribute(phase, 1));

    const pointsMat = new THREE.ShaderMaterial({
      transparent: true,
      depthWrite: false,
      blending: THREE.AdditiveBlending,
      uniforms: {
        uTime: { value: 0 },
        uSize: { value: 12.0 * Math.min(window.devicePixelRatio, 2) },
        uBlue: { value: new THREE.Color("#6aaeff") },
        uOrange: { value: new THREE.Color("#ff9a4a") }
      },
      vertexShader: `
        uniform float uTime;
        uniform float uSize;
        attribute float aPhase;
        varying float vMix;
        varying float vFade;

        // hash noise (lekki, szybki)
        float hash(vec3 p){
          p = fract(p * 0.3183099 + vec3(0.1,0.2,0.3));
          p *= 17.0;
          return fract(p.x*p.y*p.z*(p.x+p.y+p.z));
        }

        void main(){
          vec3 pos = position;

          // “pływanie” (subtelnie) + różne fazy
          float t = uTime*0.55 + aPhase;
          float n = hash(pos + t);
          pos.x += sin(t + pos.y*0.35) * 0.55 + (n-0.5)*0.25;
          pos.y += cos(t*0.9 + pos.x*0.25) * 0.35 + (n-0.5)*0.20;
          pos.z += sin(t*0.8 + pos.y*0.15) * 0.22;

          // kolor: lewa->prawa (blue->orange)
          vMix = smoothstep(-18.0, 18.0, pos.x);

          vec4 mv = modelViewMatrix * vec4(pos, 1.0);
          gl_Position = projectionMatrix * mv;

          // rozmiar punktu zależny od głębi
          float size = uSize / max(1.0, -mv.z);
          gl_PointSize = clamp(size, 2.0, 16.0);

          // fade w centrum (pod logo)
          float center = exp(-(pos.x*pos.x)/(2.0*55.0) - (pos.y*pos.y)/(2.0*18.0));
          vFade = 1.0 - 0.55*center;
        }
      `,
      fragmentShader: `
        uniform vec3 uBlue;
        uniform vec3 uOrange;
        varying float vMix;
        varying float vFade;

        void main(){
          // miękka kropka
          vec2 uv = gl_PointCoord*2.0 - 1.0;
          float d = dot(uv, uv);
          float alpha = smoothstep(1.0, 0.0, d);
          alpha = pow(alpha, 1.6) * 0.85 * vFade;

          vec3 col = mix(uBlue, uOrange, vMix);
          gl_FragColor = vec4(col, alpha);
        }
      `
    });

    const points = new THREE.Points(pointsGeo, pointsMat);
    scene.add(points);

    // Linie: precompute najbliższych sąsiadów (premium wygląda, a nadal jest szybkie)
    const positions = [];
    const indices = [];
    const pts = [];
    for(let i=0;i<POINTS;i++){
      pts.push(new THREE.Vector3(base[i*3], base[i*3+1], base[i*3+2]));
    }

    // znajdź k najbliższych (O(n^2) dla 140 = ok)
    for(let i=0;i<POINTS;i++){
      const dists = [];
      for(let j=0;j<POINTS;j++){
        if(i===j) continue;
        const dx=pts[i].x-pts[j].x, dy=pts[i].y-pts[j].y, dz=pts[i].z-pts[j].z;
        const dist = dx*dx+dy*dy+dz*dz;
        dists.push([dist, j]);
      }
      dists.sort((a,b)=>a[0]-b[0]);
      for(let k=0;k<CONNECTIONS_PER_POINT;k++){
        const j = dists[k][1];
        indices.push(i, j);
      }
    }

    // geometry linii (z dynamiczną animacją w shaderze)
    const lineGeo = new THREE.BufferGeometry();
    lineGeo.setAttribute("position", new THREE.BufferAttribute(base.slice(), 3));
    lineGeo.setIndex(indices);

    const lineMat = new THREE.ShaderMaterial({
      transparent: true,
      depthWrite: false,
      blending: THREE.AdditiveBlending,
      uniforms: {
        uTime: { value: 0 },
        uBlue: { value: new THREE.Color("#6aaeff") },
        uOrange: { value: new THREE.Color("#ff9a4a") },
        uOpacity: { value: 0.38 }
      },
      vertexShader: `
        uniform float uTime;
        attribute vec3 position;
        varying float vMix;
        varying float vFade;

        float hash(vec3 p){
          p = fract(p * 0.3183099 + vec3(0.1,0.2,0.3));
          p *= 17.0;
          return fract(p.x*p.y*p.z*(p.x+p.y+p.z));
        }

        void main(){
          vec3 pos = position;

          float t = uTime*0.55;
          float n = hash(pos + t);

          pos.x += sin(t + pos.y*0.35) * 0.55 + (n-0.5)*0.25;
          pos.y += cos(t*0.9 + pos.x*0.25) * 0.35 + (n-0.5)*0.20;
          pos.z += sin(t*0.8 + pos.y*0.15) * 0.22;

          vMix = smoothstep(-18.0, 18.0, pos.x);

          float center = exp(-(pos.x*pos.x)/(2.0*55.0) - (pos.y*pos.y)/(2.0*18.0));
          vFade = 1.0 - 0.62*center;

          gl_Position = projectionMatrix * modelViewMatrix * vec4(pos, 1.0);
        }
      `,
      fragmentShader: `
        uniform vec3 uBlue;
        uniform vec3 uOrange;
        uniform float uOpacity;
        varying float vMix;
        varying float vFade;

        void main(){
          vec3 col = mix(uBlue, uOrange, vMix);
          gl_FragColor = vec4(col, uOpacity * vFade);
        }
      `
    });

    const lines = new THREE.LineSegments(lineGeo, lineMat);
    scene.add(lines);

    // Subtelna mgiełka (premium “depth”)
    scene.fog = new THREE.FogExp2(0xffffff, 0.012);

    // Parallax
    const mouse = { x:0, y:0 };
    let targetRotX = 0, targetRotY = 0;

    hero.addEventListener("pointermove", (e)=>{
      const r = hero.getBoundingClientRect();
      const nx = ( (e.clientX - r.left) / r.width ) * 2 - 1;
      const ny = ( (e.clientY - r.top) / r.height ) * 2 - 1;
      mouse.x = nx; mouse.y = ny;
      targetRotY = nx * 0.14;
      targetRotX = -ny * 0.10;
    });

    // Anim loop
    const clock = new THREE.Clock();
    function animate(){
      const t = clock.getElapsedTime();

      pointsMat.uniforms.uTime.value = t;
      lineMat.uniforms.uTime.value = t;

      // Smooth parallax
      points.rotation.y += (targetRotY - points.rotation.y) * 0.04;
      points.rotation.x += (targetRotX - points.rotation.x) * 0.04;
      lines.rotation.copy(points.rotation);

      // Delikatny drift całej sceny
      points.position.x = Math.sin(t*0.15) * 0.25;
      points.position.y = Math.cos(t*0.12) * 0.18;
      lines.position.copy(points.position);

      composer.render();
      requestAnimationFrame(animate);
    }
    animate();

    // Resize
    const ro = new ResizeObserver(()=>{
      const w = hero.clientWidth, h = hero.clientHeight;
      renderer.setSize(w, h, false);
      camera.aspect = w/h;
      camera.updateProjectionMatrix();
      composer.setSize(w, h);
      bloom.setSize(w, h);
    });
    ro.observe(hero);

    // Reduced motion: zamroź animację jeśli user preferuje
    if (window.matchMedia && window.matchMedia("(prefers-reduced-motion: reduce)").matches){
      hero.style.background = "radial-gradient(ellipse at center, #ffffff 0%, #f6f7f9 55%, #ffffff 100%)";
      // zatrzymaj loop: zamiast requestAnimationFrame, render 1 klatkę
      pointsMat.uniforms.uTime.value = 1.0;
      lineMat.uniforms.uTime.value = 1.0;
      composer.render();
    }
  </script>
</body>
</html>
