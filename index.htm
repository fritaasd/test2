<!doctype html>
<html lang="pl">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>DS Europe – Hero</title>
  <style>
    :root{ --bg1:#ffffff; --bg2:#f5f7fb; }
    html,body{ height:100%; }
    body{ margin:0; background:var(--bg1); font-family:system-ui,-apple-system,Segoe UI,Roboto,Arial,sans-serif; }
    .hero{
      position:relative;
      height:min(72vh, 640px);
      min-height:520px;
      overflow:hidden;
      background: radial-gradient(ellipse at center, var(--bg1) 0%, var(--bg2) 55%, var(--bg1) 100%);
    }
    canvas{ position:absolute; inset:0; width:100%; height:100%; display:block; }
    .overlay{
      position:absolute; inset:0;
      display:flex; align-items:center; justify-content:center;
      pointer-events:none;
    }
    .glass{
      position:absolute;
      width:min(680px, 88vw);
      height:min(220px, 28vh);
      border-radius:28px;
      background: rgba(255,255,255,.55);
      backdrop-filter: blur(12px);
      -webkit-backdrop-filter: blur(12px);
      box-shadow: 0 22px 70px rgba(0,0,0,.08);
      border: 1px solid rgba(255,255,255,.65);
      opacity:.55;
    }
    .logo{
      width:min(420px, 76vw);
      height:auto;
      filter: drop-shadow(0 14px 34px rgba(0,0,0,.12));
      transform: translateZ(0);
    }
    @media (prefers-reduced-motion: reduce){
      .glass{ display:none; }
    }
  </style>
</head>
<body>
  <section class="hero" id="hero">
    <canvas id="c"></canvas>
    <div class="overlay">
      <div class="glass"></div>
      <img class="logo" src="logo.png" alt="ds europe" />
    </div>
  </section>

  <!-- Three.js (bez modułów) -->
  <script src="https://cdn.jsdelivr.net/npm/three@0.160.0/build/three.min.js"></script>

  <script>
    (function(){
      const hero = document.getElementById("hero");
      const canvas = document.getElementById("c");
      if(!hero || !canvas || !window.THREE){
        console.error("Brak THREE lub brak elementów DOM.");
        return;
      }

      const renderer = new THREE.WebGLRenderer({
        canvas,
        antialias: true,
        alpha: true,
        powerPreference: "high-performance"
      });
      renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));

      const scene = new THREE.Scene();
      const camera = new THREE.PerspectiveCamera(42, 1, 0.1, 200);
      camera.position.set(0, 0, 26);

      // Premium: miękki “fog” dla głębi
      scene.fog = new THREE.FogExp2(0xffffff, 0.012);

      // Parametry
      const POINTS = 150;              // 120–200
      const RADIUS = 18;
      const CONNECTIONS = 3;           // 2–4
      const linkMax = 6.8;             // dystans łączenia (mniejszy = bardziej “czysto”)

      // Rozkład z pustym środkiem (pod logo)
      function samplePoint(){
        for(let tries=0; tries<50; tries++){
          const x = (Math.random()*2 - 1) * RADIUS;
          const y = (Math.random()*2 - 1) * (RADIUS*0.55);
          const z = (Math.random()*2 - 1) * 4.0;

          const cx = x/9.0, cy = y/4.0;
          const center = Math.exp(-(cx*cx + cy*cy));
          if (Math.random() < (1 - 0.78*center)) return new THREE.Vector3(x,y,z);
        }
        return new THREE.Vector3(
          (Math.random()*2 - 1) * RADIUS,
          (Math.random()*2 - 1) * (RADIUS*0.55),
          (Math.random()*2 - 1) * 4.0
        );
      }

      const pts = [];
      const phase = new Float32Array(POINTS);
      for(let i=0;i<POINTS;i++){
        pts.push(samplePoint());
        phase[i] = Math.random()*Math.PI*2;
      }

      // Punkty: Sprites + additive (daje “glow” bez postprocessingu)
      const spriteTex = (function(){
        const s = 128;
        const cnv = document.createElement("canvas");
        cnv.width = cnv.height = s;
        const ctx = cnv.getContext("2d");
        const g = ctx.createRadialGradient(s/2,s/2,0, s/2,s/2,s/2);
        g.addColorStop(0, "rgba(255,255,255,1)");
        g.addColorStop(0.25, "rgba(255,255,255,0.6)");
        g.addColorStop(1, "rgba(255,255,255,0)");
        ctx.fillStyle = g;
        ctx.fillRect(0,0,s,s);
        const tex = new THREE.CanvasTexture(cnv);
        tex.minFilter = THREE.LinearFilter;
        tex.magFilter = THREE.LinearFilter;
        return tex;
      })();

      const pointsGeo = new THREE.BufferGeometry();
      const pos = new Float32Array(POINTS*3);
      for(let i=0;i<POINTS;i++){
        pos[i*3+0]=pts[i].x; pos[i*3+1]=pts[i].y; pos[i*3+2]=pts[i].z;
      }
      pointsGeo.setAttribute("position", new THREE.BufferAttribute(pos, 3));

      const pointsMat = new THREE.PointsMaterial({
        size: 0.38,
        map: spriteTex,
        transparent: true,
        depthWrite: false,
        blending: THREE.AdditiveBlending,
        opacity: 0.95,
        color: 0xffffff
      });

      const points = new THREE.Points(pointsGeo, pointsMat);
      scene.add(points);

      // Linie: LineSegments z dynamiczną przezroczystością (premium clean)
      // Precompute najbliższych sąsiadów
      const indices = [];
      for(let i=0;i<POINTS;i++){
        const dists = [];
        for(let j=0;j<POINTS;j++){
          if(i===j) continue;
          const dx=pts[i].x-pts[j].x, dy=pts[i].y-pts[j].y, dz=pts[i].z-pts[j].z;
          const d = Math.sqrt(dx*dx+dy*dy+dz*dz);
          dists.push([d, j]);
        }
        dists.sort((a,b)=>a[0]-b[0]);
        for(let k=0;k<CONNECTIONS;k++){
          if(dists[k][0] < linkMax) indices.push(i, dists[k][1]);
        }
      }

      const lineGeo = new THREE.BufferGeometry();
      lineGeo.setAttribute("position", new THREE.BufferAttribute(pos.slice(), 3));
      lineGeo.setIndex(indices);

      // Gradient blue->orange realizujemy przez dwa materiały i “mix” via vertex colors:
      // (prosto: nadamy kolor wierzchołkom w zależności od X)
      const colors = new Float32Array(POINTS*3);
      const blue = new THREE.Color("#6aaeff");
      const orange = new THREE.Color("#ff9a4a");
      for(let i=0;i<POINTS;i++){
        const mix = (pts[i].x + RADIUS) / (2*RADIUS); // 0..1
        const c = blue.clone().lerp(orange, mix);
        colors[i*3+0]=c.r; colors[i*3+1]=c.g; colors[i*3+2]=c.b;
      }
      lineGeo.setAttribute("color", new THREE.BufferAttribute(colors, 3));

      const lineMat = new THREE.LineBasicMaterial({
        vertexColors: true,
        transparent: true,
        opacity: 0.26,
        blending: THREE.AdditiveBlending
      });

      const lines = new THREE.LineSegments(lineGeo, lineMat);
      scene.add(lines);

      // Parallax
      let targetRotX = 0, targetRotY = 0;
      hero.addEventListener("pointermove", (e)=>{
        const r = hero.getBoundingClientRect();
        const nx = ((e.clientX - r.left)/r.width)*2 - 1;
        const ny = ((e.clientY - r.top)/r.height)*2 - 1;
        targetRotY = nx * 0.14;
        targetRotX = -ny * 0.10;
      });

      // Resize
      function resize(){
        const w = hero.clientWidth, h = hero.clientHeight;
        renderer.setSize(w, h, false);
        camera.aspect = w/h;
        camera.updateProjectionMatrix();
      }
      resize();
      window.addEventListener("resize", resize);

      // Animacja: organiczne pływanie + lekki drift
      const base = pts.map(p=>p.clone());
      const clock = new THREE.Clock();

      function animate(){
        const t = clock.getElapsedTime();

        // Smooth parallax
        points.rotation.y += (targetRotY - points.rotation.y) * 0.04;
        points.rotation.x += (targetRotX - points.rotation.x) * 0.04;
        lines.rotation.copy(points.rotation);

        points.position.x = Math.sin(t*0.15) * 0.25;
        points.position.y = Math.cos(t*0.12) * 0.18;
        lines.position.copy(points.position);

        // update pozycji punktów
        const a = 0.55; // amplituda
        const b = 0.35;
        for(let i=0;i<POINTS;i++){
          const p0 = base[i];
          const ph = phase[i];
          const x = p0.x + Math.sin(t*0.55 + ph + p0.y*0.18) * a;
          const y = p0.y + Math.cos(t*0.48 + ph + p0.x*0.14) * b;
          const z = p0.z + Math.sin(t*0.40 + ph + p0.y*0.10) * 0.22;
          pos[i*3+0]=x; pos[i*3+1]=y; pos[i*3+2]=z;
        }
        pointsGeo.attributes.position.needsUpdate = true;
        lineGeo.attributes.position.needsUpdate = true;

        // delikatny “pulse” intensywności (premium)
        lineMat.opacity = 0.20 + (Math.sin(t*0.6)*0.5+0.5)*0.10;

        renderer.render(scene, camera);
        requestAnimationFrame(animate);
      }

      // Reduced motion
      if (window.matchMedia && window.matchMedia("(prefers-reduced-motion: reduce)").matches){
        renderer.render(scene, camera);
        return;
      }

      animate();
    })();
  </script>
</body>
</html>
